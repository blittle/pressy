{"version":3,"sources":["../../../../node_modules/.pnpm/tsup@8.5.1_typescript@5.9.3_yaml@2.8.2/node_modules/tsup/assets/esm_shims.js","../../src/vite/plugin.ts","../../src/mdx/processor.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import { Plugin, ViteDevServer } from 'vite'\nimport { resolve, join, relative, basename, dirname } from 'path'\nimport { existsSync, readFileSync } from 'fs'\nimport fastGlob from 'fast-glob'\nimport yaml from 'yaml'\nimport matter from 'gray-matter'\nimport type { PressyConfig } from '../config.js'\nimport type { Book, Article, Chapter, ContentManifest, Route } from '../types.js'\nimport { compileMDX } from '../mdx/processor.js'\n\nconst VIRTUAL_MODULE_ID = 'virtual:pressy'\nconst RESOLVED_VIRTUAL_MODULE_ID = '\\0' + VIRTUAL_MODULE_ID\n\nexport function pressyPlugin(config: PressyConfig): Plugin[] {\n  let root: string\n  let contentDir: string\n  let manifest: ContentManifest = { books: [], articles: [] }\n  let routes: Route[] = []\n\n  const contentDiscovery = {\n    async discoverContent(): Promise<ContentManifest> {\n      const books = await this.discoverBooks()\n      const articles = await this.discoverArticles()\n      return { books, articles }\n    },\n\n    async discoverBooks(): Promise<Book[]> {\n      const booksDir = join(contentDir, 'books')\n      if (!existsSync(booksDir)) return []\n\n      const bookDirs = await fastGlob('*', {\n        cwd: booksDir,\n        onlyDirectories: true,\n      })\n\n      const books: Book[] = []\n\n      for (const bookSlug of bookDirs) {\n        const bookPath = join(booksDir, bookSlug)\n        const metadataPath = join(bookPath, '_book.yaml')\n\n        if (!existsSync(metadataPath)) continue\n\n        const metadataContent = readFileSync(metadataPath, 'utf-8')\n        const metadata = yaml.parse(metadataContent)\n\n        // Find chapters\n        const chapterFiles = await fastGlob('*.mdx', {\n          cwd: bookPath,\n          ignore: ['_*.mdx'],\n        })\n\n        const chapters: Chapter[] = chapterFiles\n          .map((file) => {\n            const match = file.match(/^(\\d+)-(.+)\\.mdx$/)\n            if (!match) return null\n\n            const order = parseInt(match[1], 10)\n            const slug = match[2]\n            const filePath = join(bookPath, file)\n            const content = readFileSync(filePath, 'utf-8')\n            const { data } = matter(content)\n\n            return {\n              slug,\n              title: data.title || slug.replace(/-/g, ' '),\n              order,\n              filePath,\n              wordCount: content.split(/\\s+/).length,\n              readingTime: Math.ceil(content.split(/\\s+/).length / 200),\n            }\n          })\n          .filter((c): c is Chapter => c !== null)\n          .sort((a, b) => a.order - b.order)\n\n        const coverPath = existsSync(join(bookPath, 'cover.jpg'))\n          ? join(bookPath, 'cover.jpg')\n          : existsSync(join(bookPath, 'cover.png'))\n          ? join(bookPath, 'cover.png')\n          : undefined\n\n        books.push({\n          slug: bookSlug,\n          metadata,\n          chapters,\n          basePath: bookPath,\n          coverPath,\n        })\n      }\n\n      return books\n    },\n\n    async discoverArticles(): Promise<Article[]> {\n      const articlesDir = join(contentDir, 'articles')\n      if (!existsSync(articlesDir)) return []\n\n      const articleDirs = await fastGlob('*', {\n        cwd: articlesDir,\n        onlyDirectories: true,\n      })\n\n      const articles: Article[] = []\n\n      for (const articleSlug of articleDirs) {\n        const articlePath = join(articlesDir, articleSlug)\n        const metadataPath = join(articlePath, '_article.yaml')\n        const indexPath = join(articlePath, 'index.mdx')\n\n        if (!existsSync(indexPath)) continue\n\n        let metadata: Article['metadata']\n        if (existsSync(metadataPath)) {\n          metadata = yaml.parse(readFileSync(metadataPath, 'utf-8'))\n        } else {\n          const content = readFileSync(indexPath, 'utf-8')\n          const { data } = matter(content)\n          metadata = data as Article['metadata']\n        }\n\n        const content = readFileSync(indexPath, 'utf-8')\n\n        articles.push({\n          slug: articleSlug,\n          metadata,\n          filePath: indexPath,\n          basePath: articlePath,\n          wordCount: content.split(/\\s+/).length,\n          readingTime: Math.ceil(content.split(/\\s+/).length / 200),\n        })\n      }\n\n      return articles\n    },\n  }\n\n  function generateRoutes(manifest: ContentManifest): Route[] {\n    const routes: Route[] = [\n      { path: '/', type: 'home' },\n      { path: '/books', type: 'books' },\n      { path: '/articles', type: 'articles' },\n    ]\n\n    for (const book of manifest.books) {\n      routes.push({\n        path: `/books/${book.slug}`,\n        type: 'book',\n        content: book,\n      })\n\n      for (const chapter of book.chapters) {\n        routes.push({\n          path: `/books/${book.slug}/${chapter.slug}`,\n          type: 'chapter',\n          content: chapter,\n          book,\n        })\n      }\n    }\n\n    for (const article of manifest.articles) {\n      routes.push({\n        path: `/articles/${article.slug}`,\n        type: 'article',\n        content: article,\n      })\n    }\n\n    return routes\n  }\n\n  function generateHTML(route: Route): string {\n    const title = getRouteTitle(route, config)\n    const description = getRouteDescription(route, config)\n\n    return `<!DOCTYPE html>\n<html lang=\"${config.site.language || 'en'}\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>${title}</title>\n  <meta name=\"description\" content=\"${description}\">\n  <link rel=\"stylesheet\" href=\"/@pressy/typography/prose.css\">\n  <link rel=\"stylesheet\" href=\"/@pressy/typography/fluid.css\">\n  <link rel=\"stylesheet\" href=\"/@pressy/typography/themes/light.css\" id=\"theme-light\">\n  <link rel=\"manifest\" href=\"/manifest.webmanifest\">\n  <meta name=\"theme-color\" content=\"#ffffff\">\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"module\" src=\"/@pressy/client\"></script>\n  <script type=\"module\">\n    import { hydrate } from '/@pressy/client';\n    hydrate(${JSON.stringify({ route: route.path, manifest })});\n  </script>\n</body>\n</html>`\n  }\n\n  function getRouteTitle(route: Route, config: PressyConfig): string {\n    switch (route.type) {\n      case 'home':\n        return config.site.title\n      case 'books':\n        return `Books | ${config.site.title}`\n      case 'articles':\n        return `Articles | ${config.site.title}`\n      case 'book':\n        return `${(route.content as Book).metadata.title} | ${config.site.title}`\n      case 'chapter':\n        return `${(route.content as Chapter).title} | ${route.book?.metadata.title} | ${config.site.title}`\n      case 'article':\n        return `${(route.content as Article).metadata.title} | ${config.site.title}`\n      default:\n        return config.site.title\n    }\n  }\n\n  function getRouteDescription(route: Route, config: PressyConfig): string {\n    switch (route.type) {\n      case 'book':\n        return (route.content as Book).metadata.description || ''\n      case 'article':\n        return (route.content as Article).metadata.description || ''\n      default:\n        return config.site.description || ''\n    }\n  }\n\n  return [\n    {\n      name: 'pressy:config',\n      configResolved(resolvedConfig) {\n        root = resolvedConfig.root\n        contentDir = resolve(root, config.contentDir || 'content')\n      },\n    },\n    {\n      name: 'pressy:content',\n      async buildStart() {\n        manifest = await contentDiscovery.discoverContent()\n        routes = generateRoutes(manifest)\n      },\n      resolveId(id) {\n        if (id === VIRTUAL_MODULE_ID) {\n          return RESOLVED_VIRTUAL_MODULE_ID\n        }\n        if (id === '/@pressy/client') {\n          return resolve(__dirname, '../runtime/client.js')\n        }\n        if (id.startsWith('/@pressy/typography/')) {\n          const cssFile = id.replace('/@pressy/typography/', '')\n          return { id: `@pressy/typography/${cssFile}`, external: false }\n        }\n      },\n      load(id) {\n        if (id === RESOLVED_VIRTUAL_MODULE_ID) {\n          return `export const manifest = ${JSON.stringify(manifest)};\nexport const routes = ${JSON.stringify(routes)};\nexport const config = ${JSON.stringify(config)};`\n        }\n      },\n    },\n    {\n      name: 'pressy:mdx',\n      async transform(code, id) {\n        if (!id.endsWith('.mdx')) return null\n\n        const result = await compileMDX(code, id)\n        return {\n          code: result.code,\n          map: result.map,\n        }\n      },\n    },\n    {\n      name: 'pressy:html',\n      configureServer(server: ViteDevServer) {\n        return () => {\n          server.middlewares.use(async (req, res, next) => {\n            const url = req.url || '/'\n            const route = routes.find((r) => r.path === url)\n\n            if (route) {\n              const html = generateHTML(route)\n              const transformed = await server.transformIndexHtml(url, html)\n              res.setHeader('Content-Type', 'text/html')\n              res.end(transformed)\n              return\n            }\n\n            next()\n          })\n        }\n      },\n    },\n    {\n      name: 'pressy:build',\n      async generateBundle(_, bundle) {\n        // Generate HTML files for each route during build\n        for (const route of routes) {\n          const html = generateHTML(route)\n          const fileName = route.path === '/' ? 'index.html' : `${route.path.slice(1)}/index.html`\n\n          this.emitFile({\n            type: 'asset',\n            fileName,\n            source: html,\n          })\n        }\n\n        // Generate manifest.webmanifest\n        const webManifest = {\n          name: config.site.title,\n          short_name: config.site.title,\n          description: config.site.description,\n          start_url: '/',\n          display: 'standalone',\n          background_color: '#ffffff',\n          theme_color: '#ffffff',\n          icons: [\n            {\n              src: '/icon-192.png',\n              sizes: '192x192',\n              type: 'image/png',\n            },\n            {\n              src: '/icon-512.png',\n              sizes: '512x512',\n              type: 'image/png',\n            },\n          ],\n        }\n\n        this.emitFile({\n          type: 'asset',\n          fileName: 'manifest.webmanifest',\n          source: JSON.stringify(webManifest, null, 2),\n        })\n      },\n    },\n  ]\n}\n","import { compile } from '@mdx-js/mdx'\nimport remarkGfm from 'remark-gfm'\nimport rehypeSlug from 'rehype-slug'\nimport rehypeAutolinkHeadings from 'rehype-autolink-headings'\nimport matter from 'gray-matter'\n\nexport interface MDXCompileResult {\n  code: string\n  map: string | null\n  frontmatter: Record<string, unknown>\n}\n\nexport async function compileMDX(\n  source: string,\n  filePath: string\n): Promise<MDXCompileResult> {\n  // Extract frontmatter\n  const { content, data: frontmatter } = matter(source)\n\n  // Compile MDX\n  const result = await compile(content, {\n    jsx: true,\n    jsxImportSource: 'preact',\n    remarkPlugins: [remarkGfm],\n    rehypePlugins: [\n      rehypeSlug,\n      [\n        rehypeAutolinkHeadings,\n        {\n          behavior: 'wrap',\n          properties: {\n            className: ['anchor-link'],\n          },\n        },\n      ],\n    ],\n    development: process.env.NODE_ENV !== 'production',\n  })\n\n  // Generate code that exports the compiled component\n  const code = `\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from 'preact/jsx-runtime';\nimport * as runtime from 'preact/jsx-runtime';\nimport { useMDXComponents } from '@pressy/components/content';\n\n${result.value}\n\nexport const frontmatter = ${JSON.stringify(frontmatter)};\nexport default function MDXContent(props) {\n  const components = useMDXComponents();\n  return _MDXContent({ ...props, components });\n}\n`\n\n  return {\n    code,\n    map: null,\n    frontmatter,\n  }\n}\n\n// Helper to extract table of contents from MDX\nexport function extractTableOfContents(source: string): Array<{\n  level: number\n  text: string\n  slug: string\n}> {\n  const headingRegex = /^(#{1,6})\\s+(.+)$/gm\n  const toc: Array<{ level: number; text: string; slug: string }> = []\n  let match\n\n  while ((match = headingRegex.exec(source)) !== null) {\n    const level = match[1].length\n    const text = match[2].trim()\n    const slug = text\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/^-|-$/g, '')\n\n    toc.push({ level, text, slug })\n  }\n\n  return toc\n}\n\n// Calculate reading time\nexport function calculateReadingTime(content: string): number {\n  const wordsPerMinute = 200\n  const words = content.trim().split(/\\s+/).length\n  return Math.ceil(words / wordsPerMinute)\n}\n"],"mappings":"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","names":["matter","matter","content","manifest","routes","config"]}